#!/usr/bin/env python
# -*- coding:utf-8 -*-
###
# @file          : vivado2bookshelf-pl.py
# @project       : Design_2
# @author        : Jing Mai <jingmai@pku.edu.cn>
# @created date  : July 25 2023, 22:01:12, Tuesday
# @brief         :
# -----
# Last Modified: August 10 2023, 16:20:39, Thursday
# Modified By: Jing Mai <jingmai@pku.edu.cn>
# -----
# @history :
# ====================================================================================
# Date         	By     	(version)	Comments
# -------------	-------	---------	--------------------------------------------------
# ====================================================================================
# Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
# -----
# This header is generated by VSCode extension psi-header.
###
# %%
import os.path as osp
import pandas as pd
import numpy as np
from enum import Enum

# %%
nodes_path = osp.join(".", "design.nodes")
scl_path = osp.join(".", "design.scl")
vivado_path = osp.join(".", "cell_loc.csv")
vivado_pl = osp.join(".", "vivado.pl")

# %%
df = pd.read_csv(vivado_path)
# %%
with open(nodes_path, "r") as f:
    lines = f.readlines()
    lines = filter(lambda x: not x.startswith("#"), lines)
    nodes = pd.DataFrame({"NAME": map(lambda x: x.strip().split(" ")[0], lines)})


# %%
num_nodes = len(nodes)
print("num_nodes: ", num_nodes)
# %%
# in nodes but not in df['name']
nodes_not_in_df = nodes[~nodes["NAME"].isin(df["NAME"])]
print("Nodes not in df['NAME']:", nodes_not_in_df)

# %%
merged_nodes = pd.merge(nodes, df, on="NAME", how="outer")
merged_nodes.head()


# %%

with open(scl_path, "r") as f:
    lines = f.readlines()
    start_sitemap = False
    records = []
    for line in lines:
        if line.startswith("SITEMAP"):
            start_sitemap = True
            continue
        if line.startswith("END SITEMAP"):
            start_sitemap = False
            continue
        if not start_sitemap:
            continue
        line = line.strip().split(" ")
        assert len(line) == 3
        records.append([int(line[0]), int(line[1]), line[2]])

# %%
bookshelf_sitemap = pd.DataFrame(records, columns=["x", "y", "name"])
bookshelf_sitemap.head()

# %%
# check if there are NaNs in merged_nodes, print the rows
merged_nodes[merged_nodes.isnull().T.any()]


# %%
class SiteType(Enum):
    SLICE = 0
    DSP = 1
    BRAM = 2
    IO = 3
    BUFG = 4

    def __str__(self) -> str:
        return str(self.name)

# %%


class Converter(object):
    def __init__(self, bookshelf_sitemap: pd.DataFrame) -> None:
        self.bookshelf_sitemap = bookshelf_sitemap
        site_types = list(map(lambda x: str(x), SiteType))
        self.bookshelf_xlist = {
            site_type: sorted(
                bookshelf_sitemap[bookshelf_sitemap["name"] == site_type]["x"].unique()
            )
            for site_type in site_types
        }
        self.bookshelf_xlist["BUFG"] = self.bookshelf_xlist["IO"]

    def bookshelf_x(self, loc_x: int, site_type: SiteType):
        return self.bookshelf_xlist[str(site_type)][loc_x]

    def bookshelf_y(self, location):
        # generally speaking, we have to look up the bookshelf_sitemap
        # but for now, we just use the following rules
        site_type = location.site_type
        if site_type == SiteType.SLICE:
            return location.loc_y
        elif site_type == SiteType.DSP:
            return int(location.loc_y * 2.5)
        elif site_type == SiteType.BRAM:
            return location.loc_y * 5
        elif site_type == SiteType.IO:
            return (location.loc_y // 26) * 30
        elif site_type == SiteType.BUFG:
            return (location.loc_y // 12) * 30

    def bookshelf_z(self, location):
        site_type = location.site_type
        if site_type == SiteType.SLICE:
            bel = location.bel
            if bel.endswith("FF"):  # SLICEL.DFF -> ('D' - 'A') * 2
                return (ord(bel.split(".")[1][:-2]) - ord("A")) * 2
            elif bel.endswith("FF2"):  # SLICEL.DFF2 -> ('D' - 'A') * 2 + 1
                return (ord(bel.split(".")[1].split("FF2")[0]) - ord("A")) * 2 + 1
            elif bel.endswith("6LUT"):  # SLICEL.A6LUT -> ('A' - 'A') * 2
                return (ord(bel.split(".")[1].split("6LUT")[0]) - ord("A")) * 2
            elif bel.endswith("5LUT"):  # SLICEL.A5LUT -> ('A' - 'A') * 2
                return (ord(bel.split(".")[1].split("5LUT")[0]) - ord("A")) * 2
            else:
                raise ValueError("Unknown bel: {}".format(bel))

        elif site_type == SiteType.DSP:
            return 0

        elif site_type == SiteType.BRAM:
            return 0

        elif site_type == SiteType.IO:
            return location.loc_y % 26

        elif site_type == SiteType.BUFG:

            return location.loc_y % 12

        else:
            raise ValueError("Unknown site type.")


converter = Converter(bookshelf_sitemap)


# %%
class Location(object):
    def __init__(self, loc: str, bel: str, converter: Converter):
        self.loc = loc  # e.g., DSP48E2_X17Y6
        self.bel = bel  # e.g., DSP48E2.DSP_ALU, SLICEM.HFF2, etc.
        self.converter = converter

    @property
    def loc_x(self):
        return int(self.loc.split("X")[1].split("Y")[0])

    @property
    def loc_y(self):
        return int(self.loc.split("Y")[1])

    @property
    def site_type(self):
        if self.bel.startswith("SLICE"):
            return SiteType.SLICE
        elif self.bel.startswith("DSP48E2"):
            return SiteType.DSP
        elif self.bel.startswith("RAMB36"):
            return SiteType.BRAM
        elif self.bel.startswith("HPIOB"):
            return SiteType.IO
        elif self.bel.startswith("BUFG"):
            return SiteType.BUFG
        else:
            raise ValueError("Unknown site type: {}".format(self.bel))

    @property
    def bookshelf_x(self):
        return self.converter.bookshelf_x(self.loc_x, self.site_type)

    @property
    def bookshelf_y(self):
        return self.converter.bookshelf_y(self)

    @property
    def bookshelf_z(self):
        return self.converter.bookshelf_z(self)


# %%
location = Location("DSP48E2_X17Y6", "DSP48E2.DSP_ALU", converter)
assert location.bookshelf_x == 186
assert location.bookshelf_y == 15
assert location.bookshelf_z == 0

# %%
location = Location("BUFGCE_X1Y37", "BUFGCE.BUFCE", converter)
assert location.bookshelf_x == 138
assert location.bookshelf_y == 90
assert location.bookshelf_z == 1

# %%
merged_nodes["bookshelf_x"] = merged_nodes.apply(
    lambda x: np.nan
    if x.isnull().values.any()
    else Location(x["LOC"], x["BEL"], converter).bookshelf_x,
    axis=1,
)
# %%
merged_nodes["bookshelf_y"] = merged_nodes.apply(
    lambda x: np.nan
    if x.isnull().values.any()
    else Location(x["LOC"], x["BEL"], converter).bookshelf_y,
    axis=1,
)

# %%
merged_nodes["bookshelf_z"] = merged_nodes.apply(
    lambda x: np.nan
    if x.isnull().values.any()
    else Location(x["LOC"], x["BEL"], converter).bookshelf_z,
    axis=1,
)

# %%
merged_nodes.head()

# %%
with open(vivado_pl, "w") as f:
    # drop the rows with NaNs
    nodes_without_nan = merged_nodes.dropna()
    for _, row in nodes_without_nan.iterrows():
        f.write(
            "{} {} {} {} FIXED\n".format(
                row["NAME"],
                int(row["bookshelf_x"]),
                int(row["bookshelf_y"]),
                int(row["bookshelf_z"]),
            )
        )

# %%

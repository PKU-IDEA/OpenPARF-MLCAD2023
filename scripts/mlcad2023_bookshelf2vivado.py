#!/usr/bin/env python
# -*- coding:utf-8 -*-
###
# @file          : mlcad2023_bookshelf2pl.py
# @project       : OpenPARF
# @author        : Jing Mai <jingmai@pku.edu.cn>
# @created date  : August 08 2023, 19:45:44, Tuesday
# @brief         :
# -----
# Last Modified: September 11 2023, 10:26:33, Monday
# Modified By: Jing Mai <jingmai@pku.edu.cn>
# -----
# @history :
# ====================================================================================
# Date         	By     	(version)	Comments
# -------------	-------	---------	--------------------------------------------------
# ====================================================================================
# Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
# -----
# This header is generated by VSCode extension psi-header.
# only consider IOs, DSPs and BRAMs
# IO's position are fixed, and are converted from design.pl file.
# DSPs and BRAMs' position are converted from macroplacement.pl file.
###
# %%
import pathlib
import time
import os
import threading
import random
import os.path as osp
import argparse
import pandas as pd

# %%
parser = argparse.ArgumentParser()
parser.add_argument("--benchmark_dir", type=str, required=True)
parser.add_argument("--run_dir", type=str, required=True)

args = parser.parse_args()
benchmark_dir = args.benchmark_dir
run_dir = args.run_dir

# %%
assert osp.exists(run_dir), "run_dir does not exist"
benchmark_names = [d.name for d in os.scandir(benchmark_dir) if d.is_dir()]
benchmark_names = sorted(benchmark_names, key=lambda x: int(''.join(filter(str.isdigit, x))))
macro_pl_dir = os.path.join(run_dir, "solutions")
vivado_pl_dir = os.path.join(run_dir, "vivado_solutions")

# %%
print("benchmark_dir    : ", benchmark_dir)
print("run_dir          : ", run_dir)
print("macro_pl_dir     : ", macro_pl_dir)
print("vivado_pl_dir    : ", vivado_pl_dir)
print("# benchmarks     : ", len(benchmark_names))

# %%
pathlib.Path(vivado_pl_dir).mkdir(parents=True, exist_ok=True)

# %%

def extractCols(scl_path):
    dsp_cols, bram_cols = [], []
    with open(scl_path, "r") as f:
        lines = [line.strip() for line in f.readlines() if not line.startswith("#")]
    for line in lines:
        if line.endswith("DSP") and not line.startswith("SITE"):
            dsp_cols.append(int(line.split()[0]))
        elif line.endswith("BRAM") and not line.startswith("SITE"):
            bram_cols.append(int(line.split()[0]))
    return sorted(list(set(dsp_cols))), sorted(list(set(bram_cols)))


scl_path = os.path.join(benchmark_dir, benchmark_names[0], "design.scl")
dsp_cols, bram_cols = extractCols(scl_path)
# print("dsp_cols: ", dsp_cols)
# print("bram_cols: ", bram_cols)


# %%
def plToVivado(pl_path, fp):
    with open(pl_path, "r") as f:
        lines = [line for line in f.readlines() if not line.startswith("#")]
    for line in lines:
        name, xx, yy, zz, _ = line.strip().split()
        xx = int(xx)
        yy = int(yy)
        zz = int(zz)
        loc_x = 0 if xx == 68 else 1
        loc_y = yy // 30 * 26 + zz - 1
        loc = "IOB_X%dY%d" % (loc_x, loc_y)
        fp.write("%s,%s\n" % (name, loc))


def macroToVivado(macro_path, cascaded_shapes_path, fp):
    if osp.exists(cascaded_shapes_path):
        with open(cascaded_shapes_path, "r") as f:
            lines = [line.strip() for line in f.readlines() if not line.startswith("#")]
    else:
        lines = []
    flag = 0
    shape_lists = []
    macro_map = dict()
    for line in lines:
        if line.startswith("BEGIN"):
            flag = 1
            shape_lists = []
        elif line.startswith("END"):
            macro_map[shape_lists[0]] = shape_lists
            flag = 0
        elif flag == 1:
            shape_lists.append(line.strip().split()[0])
    with open(macro_path, "r") as f:
        lines = [line for line in f.readlines() if not line.startswith("#")]
    for line in lines:
        name, xx, yy, zz = line.strip().split()
        xx = int(xx)
        yy = int(yy)
        zz = int(zz)
        if "DSP" in name:
            if xx not in dsp_cols:
                print("[WARNING] %s is not in dsp_cols" % name)
                continue
            loc_x = dsp_cols.index(xx)
            loc_y = int((yy + 0.5) / 2.5)
            if name in macro_map:
                macro_list = macro_map[name]
                for i, macro in enumerate(macro_list):
                    assert len(macro) > 0
                    fp.write("%s,%s\n" % (macro, "DSP48E2_X%dY%d" % (loc_x, loc_y + i)))
            else:
                assert len(name) > 0
                fp.write("%s,%s\n" % (name, "DSP48E2_X%dY%d" % (loc_x, loc_y)))
        elif "BRAM" in name:
            if xx not in bram_cols:
                print("[WARNING] %s is not in bram_cols" % name)
                continue
            loc_x = bram_cols.index(xx)
            loc_y = int(yy // 5)
            if name in macro_map:
                macro_list = macro_map[name]
                for i, macro in enumerate(macro_list):
                    assert len(macro) > 0
                    fp.write("%s,%s\n" % (macro, "RAMB36_X%dY%d" % (loc_x, loc_y + i)))
            else:
                assert len(name) > 0
                fp.write("%s,%s\n" % (name, "RAMB36_X%dY%d" % (loc_x, loc_y)))

#%%
def transform(benchmark_name):
    pl_path = os.path.join(benchmark_dir, benchmark_name, "design.pl")
    macro_path = os.path.join(macro_pl_dir, benchmark_name, "macroplacement.pl")
    cascaded_shapes_path = os.path.join(
        benchmark_dir, benchmark_name, "design.cascade_shape_instances"
    )
    vivado_path = os.path.join(
        vivado_pl_dir, benchmark_name, "macroplacement.vivado.csv"
    )
    assert osp.exists(pl_path), "pl_path does not exist: " + pl_path
    if not osp.exists(macro_path):
        print(f"{benchmark_name}: macro_path does not exist")
        return
    pathlib.Path(osp.dirname(vivado_path)).mkdir(parents=True, exist_ok=True)
    fp = open(vivado_path, "w")
    fp.write("NAME,LOC\n")
    # plToVivado(pl_path, fp)
    macroToVivado(macro_path, cascaded_shapes_path, fp)
    fp.close()
    print(f"{benchmark_name}: success")


#%%
for benchmark_name in benchmark_names:
    try:
        transform(benchmark_name)
    except Exception as e:
        print(f"{benchmark_name} failed with exception: ", e)

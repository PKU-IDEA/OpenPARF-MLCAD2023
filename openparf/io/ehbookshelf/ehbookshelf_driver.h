/*
 * @file          : ehbookshelf_driver.h
 * @project       : ehbookshelf
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : June 29 2023, 22:59:34, Thursday
 * @brief         :
 * -----
 * Last Modified: July 14 2023, 15:55:41, Friday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */

#ifndef OPENPARF_IO_EHBOOKSHELF_EHBOOKSHELF_DRIVER_H_
#define OPENPARF_IO_EHBOOKSHELF_EHBOOKSHELF_DRIVER_H_

#include <string>
#include <utility>
#include <vector>

#include "ehbookshelf_database.h"


namespace ehbookshelfparser {

class Driver {
 public:
  explicit Driver(EHBookshelfDatabase &db);

  /// enable debug output in the flex scanner
  bool        trace_scanning;

  /// enable debug output in the bison parser
  bool        trace_parsing;

  /// stream name (file or input stream) used for error messages.
  std::string streamname;

  /** Invoke the scanner and parser for a stream.
   * @param in	input stream
   * @param sname	stream name for error messages
   * @return		true if successfully parsed
   */
  bool        parse_stream(std::istream &in, std::string const &sname = "stream input");

  /** Invoke the scanner and parser on an input string.
   * @param input	input string
   * @param sname	stream name for error messages
   * @return		true if successfully parsed
   */
  bool        parse_string(std::string const &input, std::string const &sname = "string stream");

  /** Invoke the scanner and parser on a file. Use parse_stream with a
   * std::ifstream if detection of file reading errors is required.
   * @param filename	input file name
   * @return		true if successfully parsed
   */
  bool        parse_file(std::string const &filename);

  /** Error handling with associated line number. This can be modified to
   * output the error e.g. to a dialog box. */
  void        error(const class location &l, std::string const &m);

  /** General error handling. This can be modified to output the error
   * e.g. to a dialog box. */
  void        error(std::string const &m);

  virtual ~Driver();

  /* parsing lib file */
  void addCellCbk(std::string const &str);
  void addCellInputPinCbk(std::string const &str);
  void addCellOutputPinCbk(std::string const &str);
  void addCellClockPinCbk(std::string const &str);
  void addCellCtrlPinCbk(std::string const &str);
  void addCellCtrlSRPinCbk(std::string const &str);
  void addCellCtrlCEPinCbk(std::string const &str);
  void addCellInputCasPinCbk(std::string const &str);
  void addCellOutputCasPinCbk(std::string const &str);
  void addCellParameterCbk(std::string const &str);

  /* parsing scl file */
  void setSiteTypeCbk(std::string const &str);
  void setSiteNumResourcesCbk(unsigned n);
  void endSiteBlockCbk();
  void setResourceTypeCbk(std::string const &str);
  void addToCellNameListCbk(std::string const &str);
  void addResourceTypeCbk();
  void endResourceTypeBlockCbk();
  void initSiteMapCbk(unsigned w, unsigned h);
  void endSiteMapCbk();
  void setSiteMapEntryCbk(unsigned x, unsigned y, std::string const &site_type);
  void initClockRegionsCbk(unsigned width, unsigned height);
  void addClockRegionCbk(std::string const &name,
          unsigned                          xlo,
          unsigned                          ylo,
          unsigned                          xhi,
          unsigned                          yhi,
          unsigned                          ymid,
          unsigned                          hcxmin);

  /* parsing nodes file */
  void addNodeCbk(std::string const &node_name, std::string const &cell_name);

  /* parsing pl file */
  void setFixedNodeCbk(std::string const &node_name, unsigned x, unsigned y, unsigned z);

  /* parsing nets file */
  void addNetCbk(std::string const &net_name, unsigned degree);
  void addPinCbk(std::string const &node_name, std::string const &cell_pin_name);

  /* parsing cascade shape file */
  void beginCascadeShapeCbk(const std::string &shape_name, int32_t width, int32_t height);
  void addCascadeShapeEntryCbk(const std::string &str);
  void beginCascadeShapeLineCbk();
  void addCascadeShapeLineEntryCbk(const std::string &str);
  void endCascadeShapeLineCbk();
  void endCascadeShapeCbk();

  /* parsing cascade shape instance file */
  void beginCascadeShapeInstanceCbk(const std::string &shape_name,
          int32_t                                      width,
          int32_t                                      height,
          const std::string                           &shape_instance_name);
  void addCascadeShapeInstanceEntryCbk(const std::string &str);
  void endCascadeShapeInstanceCbk();

  /* parsing region file */
  void beginRegionConstraintCbk(int32_t region_name, int32_t num_boxes);
  void addRegionConstraintEntryCbk(const std::string &box_name, int32_t xlo, int32_t ylo, int32_t xhi, int32_t yhi);
  void endRegionConstraintCbk();
  void beginRegionMappingCbk();
  void addRegionMappingEntryCbk(const std::string &cell_name, int32_t region_name);
  void endRegionMappingCbk();

  /* parsing macros file */
  void addMacroInstCbk(std::string const &node_name);

  class Parser  *parser;
  class Scanner *scanner;

 private:
  EHBookshelfDatabase     &db_;

  std::string              site_type_;                     ///< temporary storage for site type name
  std::string              resource_type_;                 ///< temporary storage for a resource type name
  std::vector<std::string> cell_name_list_;                ///< temporary storage for a resource type entry
  std::vector<std::pair<std::string, unsigned>>
                                        site_resources_;   ///< temporary storage for one site block of resources

                                                           /*** temporary storage for cascade shape ***/
  std::string                           shape_name_;
  std::pair<int32_t, int32_t>           shape_size_;
  std::vector<std::vector<std::string>> shape_list_;

  /*** temporary storage for cascade shape instance ***/
  std::string                           shape_instance_name_;
  std::vector<std::string>              shape_instance_list_;

  /*** temporary storage for region constraint ***/
  std::string                           region_name_;
  int32_t                               num_boxes_;
  std::vector<EHBookshelfDatabase::Box> region_boxes_;
};

}   // namespace ehbookshelfparser

#endif   // OPENPARF_IO_EHBOOKSHELF_EHBOOKSHELF_DRIVER_H_

/*
 * @file          : region_mcf_lg_kernel.h
 * @project       : OpenPARF
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : July 22 2023, 15:28:05, Saturday
 * @brief         :
 * -----
 * Last Modified: July 23 2023, 16:22:14, Sunday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */

#include <functional>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "database/placedb.h"
#include "lemon/list_graph.h"
#include "lemon/network_simplex.h"
#include "util/torch.h"
#include "util/util.h"

OPENPARF_BEGIN_NAMESPACE
template<typename T>
class RegionMcfLegalizer {
 public:
  using GraphType    = lemon::ListDigraph;
  using CapacityType = int32_t;
  using CostType     = int32_t;
  using SolverType   = lemon::NetworkSimplex<GraphType, CapacityType, CostType>;

  struct MinCostFlowProblem {
    using ResultType = typename SolverType::ProblemType;
    GraphType                       graph;
    GraphType::ArcMap<CapacityType> capacity_lower_bound, capacity_upper_bound;
    GraphType::ArcMap<CostType>     cost;
    GraphType::Node                 source, drain;
    CapacityType                    supply;
    SolverType                      solver;
    MinCostFlowProblem() : capacity_lower_bound(graph), capacity_upper_bound(graph), cost(graph), solver(graph) {
      source = graph.addNode();
      drain  = graph.addNode();
    }

    void dump(const std::string &dump_file) {
      std::fstream s(dump_file, s.out);
      s << "ArcID, SourceNodeId, TargetNodeId, LowerCapacity, UpperCapacity, Cost" << std::endl;
      for (GraphType::ArcIt i(graph); i != lemon::INVALID; ++i) {
        s << graph.id(i) << ", " << graph.id(graph.source(i)) << ", " << graph.id(graph.target(i)) << ", ";
        s << capacity_lower_bound[i] << ", ";
        s << capacity_upper_bound[i] << ", ";
        s << cost[i] << std::endl;
      }
      s.close();
    }

    bool solve() {
      solver.reset();
      auto res = solver.stSupply(source, drain, supply)
                         .lowerMap(capacity_lower_bound)
                         .upperMap(capacity_upper_bound)
                         .costMap(cost)
                         .run();

      if (res == ResultType::INFEASIBLE) {
        openparfPrint(MessageType::kInfo,
                "Min cost flow problem has no feasible solution. Not meaningful to continue\n");
        return false;
      } else if (res == ResultType::UNBOUNDED) {
        openparfPrint(MessageType::kError, "Min cost flow formulation is unbounded. Not meaningful to continue\n");
        return false;
      }
      openparfAssert(res == ResultType::OPTIMAL);
      return true;
    }
  };

  struct SSSIRModelInfo {
    int32_t                                                   num_insts;
    int32_t                                                   num_sites;
    std::vector<GraphType::Node>                              instance_nodes, site_nodes;
    std::vector<GraphType::Arc>                               instance_arcs, site_arcs;
    std::vector<std::tuple<int32_t, int32_t, GraphType::Arc>> inst_to_site_arcs;
    at::Tensor                                                inst_ids;
    at::Tensor                                                inst_weights;
    at::Tensor                                                inst_compatiable_sites;
    double                                                    max_distance;
    double                                                    dist_incr_per_iter;
    int32_t                                                   model_id;
  };

  explicit RegionMcfLegalizer(database::PlaceDB const &placedb) : placedb_(placedb) {
    site_per_iteration = 100;
    scale_factor       = 1000;
  }
  at::Tensor forward(at::Tensor pos, at::Tensor is_legalized_insts, database::PlaceDB const &placedb);
  void       add_sssir_instances(at::Tensor inst_ids, at::Tensor inst_weights, at::Tensor inst_compatiable_sites);

 private:
  void                        calculate_max_distance(at::Tensor pos);

  std::vector<SSSIRModelInfo> sssir_model_infos;
  MinCostFlowProblem          mcf_problem;

  std::vector<T>              max_inst_to_site_distance;
  std::vector<T>              dist_incr_per_iter;
  int32_t                     site_per_iteration;
  int32_t                     scale_factor;

  // I give up, binding is too complicated
  database::PlaceDB const    &placedb_;
};

OPENPARF_END_NAMESPACE

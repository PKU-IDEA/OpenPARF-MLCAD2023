/*
 * @file          : region_mcf_lg.cpp
 * @project       : OpenPARF
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : July 22 2023, 15:28:05, Saturday
 * @brief         :
 * -----
 * Last Modified: July 23 2023, 16:32:05, Sunday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */

#include <cstdint>
#include <vector>

#include "container/vector_2d.hpp"
#include "database/placedb.h"
#include "geometry/geometry.hpp"
#include "region_mcf_lg_kernel.h"
#include "util/message.h"
#include "util/torch.h"

OPENPARF_BEGIN_NAMESPACE

using SiteMap = database::SiteMap;
using Site    = database::Site;
using PlaceDB = database::PlaceDB;

template<typename T>
void RegionMcfLegalizer<T>::add_sssir_instances(at::Tensor inst_ids,
        at::Tensor                                         inst_weights,
        at::Tensor                                         inst_compatiable_sites) {
  // Assert correct shape of tensors
  CHECK_FLAT_CPU(inst_ids);
  CHECK_CONTIGUOUS(inst_ids);
  CHECK_FLAT_CPU(inst_weights);
  CHECK_CONTIGUOUS(inst_weights);
  CHECK_FLAT_CPU(inst_compatiable_sites);
  CHECK_DIVISIBLE(inst_compatiable_sites, 4);

  sssir_model_infos.emplace_back();
  auto &m             = sssir_model_infos.back();
  auto  inst_ids_size = inst_ids.sizes();
  openparfAssertMsg(inst_ids_size.size() == 1, "inst_ids tensor must be 1D\n");
  m.num_insts                      = inst_ids_size.front();
  auto inst_compatiable_sites_size = inst_compatiable_sites.sizes();
  openparfAssertMsg(inst_compatiable_sites_size.size() == 2, "inst_compatiable_sites tensor must be 2D\n");
  m.num_sites = inst_compatiable_sites_size.front();
  openparfAssertMsg(inst_compatiable_sites_size[1] == 4,
          "inst_compatiable_sites must have a dimension of (#num_insts, 4)\n");
  // We do not copy to save time
  // Must check the validity of data before using them
  m.inst_ids               = inst_ids;
  m.inst_weights           = inst_weights;
  m.inst_compatiable_sites = inst_compatiable_sites;
  openparfPrint(MessageType::kInfo, "Added %i SSSIR instances and %i target sites\n", m.num_insts, m.num_sites);
  for (int32_t i = 0; i < m.num_insts; i++) {
    m.instance_nodes.emplace_back(mcf_problem.graph.addNode());
    m.instance_arcs.emplace_back(mcf_problem.graph.addArc(mcf_problem.source, m.instance_nodes.back()));
    auto &arc                             = m.instance_arcs.back();
    mcf_problem.cost[arc]                 = 0;
    mcf_problem.capacity_lower_bound[arc] = 0;
    mcf_problem.capacity_upper_bound[arc] = 1;
  }
  for (int32_t i = 0; i < m.num_sites; i++) {
    m.site_nodes.emplace_back(mcf_problem.graph.addNode());
    m.site_arcs.emplace_back(mcf_problem.graph.addArc(m.site_nodes.back(), mcf_problem.drain));
    auto &arc                             = m.site_arcs.back();
    mcf_problem.cost[arc]                 = 0;
    mcf_problem.capacity_lower_bound[arc] = 0;
    mcf_problem.capacity_upper_bound[arc] = 1;
  }
}

template<typename T>
void RegionMcfLegalizer<T>::calculate_max_distance(at::Tensor pos) {
  max_inst_to_site_distance.resize(0);
  dist_incr_per_iter.resize(0);
  auto pos_acc = pos.template accessor<T, 2>();   //
  for (auto &m : sssir_model_infos) {
    auto inst_id_acc                = m.inst_ids.template accessor<int32_t, 1>();
    auto inst_weight_acc            = m.inst_weights.template accessor<T, 1>();
    auto inst_compatiable_sites_acc = m.inst_compatiable_sites.template accessor<T, 2>();

    T    min_px                     = std::numeric_limits<T>::max();
    T    min_py                     = std::numeric_limits<T>::max();
    T    max_px                     = std::numeric_limits<T>::lowest();
    T    max_py                     = std::numeric_limits<T>::lowest();
    // Range of instances
    for (int32_t i = 0; i < m.num_insts; i++) {
      int32_t inst_id = inst_id_acc[i];
      T       px      = pos_acc[inst_id][0];
      T       py      = pos_acc[inst_id][1];
      min_px          = std::min(min_px, px);
      min_py          = std::min(min_py, py);
      max_px          = std::max(max_px, px);
      max_py          = std::max(max_py, py);
    }
    // Range of sites
    T min_sx = std::numeric_limits<T>::max();
    T min_sy = std::numeric_limits<T>::max();
    T max_sx = std::numeric_limits<T>::lowest();
    T max_sy = std::numeric_limits<T>::lowest();
    for (int32_t i = 0; i < m.num_sites; ++i) {
      T sx   = (inst_compatiable_sites_acc[i][0] + inst_compatiable_sites_acc[i][2]) / 2;
      T sy   = (inst_compatiable_sites_acc[i][1] + inst_compatiable_sites_acc[i][3]) / 2;
      min_sx = std::min(min_sx, sx);
      min_sy = std::min(min_sy, sy);
      max_sx = std::max(max_sx, sx);
      max_sy = std::max(max_sy, sy);
    }
    // Lower bound of maximum Manhatten distance between instances and sites of this type
    T max_dist = std::max(max_px, max_sx) - std::min(min_px, min_sx)    // x distance
               + std::max(max_py, max_sy) - std::min(min_py, min_sy);   // y distance
    m.max_distance        = static_cast<double>(max_dist);
    int32_t iteration_num = std::max((int32_t) (m.num_sites / site_per_iteration), 1);
    m.dist_incr_per_iter  = max_dist / iteration_num;
  }
}


template<typename T>
bool isRegionLegal(int32_t new_inst_id, geometry::Point<T, 2> site_pos, database::PlaceDB const &placedb) {
  auto const &region_constraint = placedb.db()->regionConstraint();
  auto const &region_list       = region_constraint.region_list();
  int32_t     old_inst_id       = placedb.oldInstId(new_inst_id);
  if (!region_constraint.ifExist(old_inst_id)) {
    return true;
  }
  auto region_id = region_constraint.inst2Region(old_inst_id);
  auto region    = region_list.at(region_id);
  return region.template contain(site_pos);
}

class ValidSiteMap {
  using IndexType = database::PlaceDB::IndexType;

 public:
  explicit ValidSiteMap(const database::PlaceDB &placedb) : site_map_(placedb.db()->layout().siteMap()) {
    valid_site_map_.resize(site_map_.width(), site_map_.height(), std::numeric_limits<IndexType>::max());
    for (auto const &site : site_map_) {
      auto const &bbox = site.bbox();
      for (int32_t ix = bbox.xl(); ix < bbox.xh(); ++ix) {
        for (int32_t iy = bbox.yl(); iy < bbox.yh(); ++iy) {
          valid_site_map_(ix, iy) = site_map_.index1D(site.siteMapId().x(), site.siteMapId().y());
        }
      }
    }
  }

  Site const &getValidSite(IndexType ix, IndexType iy) {
    auto        id1d = valid_site_map_(ix, iy);
    auto const &site = site_map_.at(id1d);
    openparfAssert(site);
    return *site;
  }

 private:
  const SiteMap                 &site_map_;
  container::Vector2D<IndexType> valid_site_map_;
};

class SiteMask {
 public:
  explicit SiteMask(const PlaceDB &placedb) : site_map_(placedb.db()->layout().siteMap()) {
    masks_.resize(placedb.db()->layout().siteMap().size());
  }

  void setSiteMask(const Site &site) {
    assert(site.id() < masks_.size());
    masks_[site.id()] = 1;
  }

  bool getSiteMask(const Site &site) {
    assert(site.id() < masks_.size());
    return masks_[site.id()];
  }

 private:
  const SiteMap       &site_map_;
  std::vector<int32_t> masks_;
};

template<typename T>
at::Tensor RegionMcfLegalizer<T>::forward(at::Tensor pos,
        at::Tensor                                   is_legalized_insts,
        database::PlaceDB const                     &placedb) {
  CHECK_CONTIGUOUS(pos);
  CHECK_DIVISIBLE(pos, 2);
  CHECK_FLAT_CPU(pos);
  CHECK_CONTIGUOUS(is_legalized_insts);
  CHECK_FLAT_CPU(is_legalized_insts);
  CHECK_TYPE(is_legalized_insts, torch::kInt32);
  // https://stackoverflow.com/questions/55266154/pytorch-preferred-way-to-copy-a-tensor
  at::Tensor   res                    = pos.clone().detach();
  // https://stackoverflow.com/questions/4942703/why-do-i-get-an-error-trying-to-call-a-template-member-function-with-an-explicit
  auto         pos_acc                = pos.template accessor<T, 2>();
  auto         acc_is_legalized_insts = is_legalized_insts.template accessor<int32_t, 1>();
  int32_t      num_models             = sssir_model_infos.size();
  ValidSiteMap valid_site_map         = ValidSiteMap(placedb);
  SiteMask     site_mask              = SiteMask(placedb);
  openparfPrint(MessageType::kInfo, "========================================================\n");
  openparfPrint(MessageType::kInfo, "Starting min cost flow legalization of %i SSSIR models\n", num_models);

  // exclude the sites that have been occupied by legalized instances
  for (int idx = 0; idx < num_models; idx++) {
    auto &m           = sssir_model_infos[idx];
    auto  inst_id_acc = m.inst_ids.template accessor<int32_t, 1>();
    for (int32_t inst_i = 0; inst_i < m.num_insts; inst_i++) {
      int32_t new_inst_id = inst_id_acc[inst_i];
      if (!acc_is_legalized_insts[new_inst_id]) {
        continue;
      }
      T     xx   = pos_acc[new_inst_id][0];
      T     yy   = pos_acc[new_inst_id][1];
      auto &site = valid_site_map.getValidSite(static_cast<int32_t>(xx), static_cast<int32_t>(yy));
      site_mask.setSiteMask(site);
      // std::cerr << "Set site mask for site " << site.id() << " at (" << site.bbox()
      //           << ") , which is occupied by instance " << new_inst_id << " at (" << xx << ", " << yy << ")"
      //           << std::endl;
    }
  }

  calculate_max_distance(pos);
  for (int idx = 0; idx < num_models; idx++) {
    openparfPrint(kInfo, "Model %i:  %i instances, %i sites\n", idx, sssir_model_infos[idx].num_insts,
            sssir_model_infos[idx].num_sites);
  }

  bool    stop_flag = false;
  bool    mcf_legal = false;
  int32_t iter      = 0;
  while (!stop_flag) {
    // purge_arcs
    std::vector<int32_t> model_supplies(num_models, 0);
    for (int idx = 0; idx < num_models; idx++) {
      auto &m       = sssir_model_infos[idx];
      T     min_dis = m.dist_incr_per_iter * iter;
      T     max_dis = m.dist_incr_per_iter * (iter + 1);
      openparfPrint(MessageType::kInfo, "Iter %i model %i: check sites with distance smaller than %f\n", iter, idx,
              max_dis);
      auto inst_id_acc                = m.inst_ids.template accessor<int32_t, 1>();
      auto inst_weight_acc            = m.inst_weights.template accessor<T, 1>();
      auto inst_compatiable_sites_acc = m.inst_compatiable_sites.template accessor<T, 2>();
      for (int32_t i = 0; i < m.num_insts; i++) {
        int32_t inst_id = inst_id_acc[i];

        if (acc_is_legalized_insts[inst_id]) {
          continue;
        }

        model_supplies[idx] += 1;

        T   inst_weight = inst_weight_acc[i];
        T   x           = pos_acc[inst_id][0];
        T   y           = pos_acc[inst_id][1];

        // std::cerr << "Instance " << inst_id << " at (" << x << ", " << y << ") with weight " << inst_weight
        //           << std::endl;

        int count       = 0;
        for (int32_t s = 0; s < m.num_sites; s++) {
          T     xl     = inst_compatiable_sites_acc[s][0];
          T     xh     = inst_compatiable_sites_acc[s][2];
          T     yl     = inst_compatiable_sites_acc[s][1];
          T     yh     = inst_compatiable_sites_acc[s][3];
          T     site_x = (xl + xh) / 2.0;
          T     site_y = (yl + yh) / 2.0;


          // exclude the sites that have been occupied by legalized instances
          auto &site   = valid_site_map.getValidSite(static_cast<int32_t>(site_x), static_cast<int32_t>(site_y));
          if (site_mask.getSiteMask(site)) {
            continue;
          }

          T m_dist = std::abs(site_x - x) + std::abs(site_y - y);
          if (m_dist >= min_dis && m_dist < max_dis &&
                  isRegionLegal(inst_id, geometry::Point<T, 2>(site_x, site_y), placedb)) {
            count += 1;
            m.inst_to_site_arcs.emplace_back(inst_id, s,
                    mcf_problem.graph.addArc(m.instance_nodes[i], m.site_nodes[s]));
            auto &arc                             = std::get<2>(m.inst_to_site_arcs.back());
            mcf_problem.cost[arc]                 = (CostType) (m_dist * inst_weight * scale_factor);
            mcf_problem.capacity_lower_bound[arc] = 0;
            mcf_problem.capacity_upper_bound[arc] = 1;
          }
        }
      }
    }

    // Solve the mcf_problem
    mcf_problem.supply = std::accumulate(model_supplies.begin(), model_supplies.end(), 0);
    mcf_problem.solve();

    // Now check if the results are legal
    stop_flag = true;
    mcf_legal = true;
    for (int32_t idx = 0; idx < num_models; idx++) {
      auto   &m          = sssir_model_infos[idx];
      int32_t total_flow = 0;
      for (auto const &arc : m.site_arcs) {
        total_flow += mcf_problem.solver.flow(arc);
      }
      openparfPrint(kInfo, "Model %i: %i instances, %i sites, %i unlegalized instances, total flow %i\n", idx,
              m.num_insts, m.num_sites, model_supplies[idx], total_flow);
      if (total_flow != model_supplies[idx]) {
        stop_flag = false;
        mcf_legal = false;
      }
    }

    if (stop_flag) {
      // retrieve the assignment
      for (auto &m : sssir_model_infos) {
        auto    inst_id_acc                = m.inst_ids.template accessor<int32_t, 1>();
        auto    inst_weight_acc            = m.inst_weights.template accessor<T, 1>();
        auto    inst_compatiable_sites_acc = m.inst_compatiable_sites.template accessor<T, 2>();
        T       total_movement             = 0;
        int32_t movement_count             = 0;
        for (auto const &arc : m.inst_to_site_arcs) {
          if (mcf_problem.solver.flow(std::get<2>(arc))) {
            int32_t inst_id = std::get<0>(arc);
            int32_t s       = std::get<1>(arc);
            T       xl      = inst_compatiable_sites_acc[s][0];
            T       xh      = inst_compatiable_sites_acc[s][2];
            T       yl      = inst_compatiable_sites_acc[s][1];
            T       yh      = inst_compatiable_sites_acc[s][3];
            T       site_x  = (xl + xh) / 2.0;
            T       site_y  = (yl + yh) / 2.0;
            T       old_x   = pos_acc[inst_id][0];
            T       old_y   = pos_acc[inst_id][1];
            total_movement += std::abs(site_x - old_x) + std::abs(site_y - old_y);
            movement_count++;
            res[inst_id][0] = site_x;
            res[inst_id][1] = site_y;
          }
        }
        openparfPrint(MessageType::kInfo, "Model %i: %i instances moved, avg movement %f\n", m.model_id, movement_count,
                movement_count == 0 ? 0 : total_movement / movement_count);
      }
    }
    iter++;
  }
  return res;
}


OPENPARF_END_NAMESPACE

#define INSTANTIATE_PYTHON_CLASS(T)                                                                                    \
  py::class_<OPENPARF_NAMESPACE::RegionMcfLegalizer<T>>(m, "RegionMcfLegalizer_" #T)                                   \
          .def(py::init<OPENPARF_NAMESPACE::database::PlaceDB const &>())                                              \
          .def("add_sssir_instances", &OPENPARF_NAMESPACE::RegionMcfLegalizer<T>::add_sssir_instances)                 \
          .def("forward", &OPENPARF_NAMESPACE::RegionMcfLegalizer<T>::forward);

PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
  INSTANTIATE_PYTHON_CLASS(float);
  INSTANTIATE_PYTHON_CLASS(double);
}

#undef INSTANTIATE_PYTHON_CLASS

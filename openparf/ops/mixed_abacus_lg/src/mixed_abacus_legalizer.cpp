/*
 * @file          : mixed_abacus_legalizer.cpp
 * @project       : OpenPARF
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : June 28 2023, 15:51:51, Wednesday
 * @brief         :
 * -----
 * Last Modified: July 23 2023, 14:36:03, Sunday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */

#include "mixed_abacus_legalizer.h"

#include <algorithm>
#include <limits>
#include <memory>
#include <set>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include "container/spiral_accessor.hpp"
#include "container/vector_2d.hpp"

OPENPARF_BEGIN_NAMESPACE

namespace mixed_abacus_legalizer {

using container::SpiralAccessor;
using container::Vector2D;
using container::XY;
using database::Resource;
using database::Site;
using database::SiteMap;

using SiteRefVec = std::vector<std::reference_wrapper<const Site>>;
using Range      = std::pair<int32_t, int32_t>;

namespace detail {

int32_t SelectResource(database::PlaceDB const &placedb, int32_t area_type_id) {
  int32_t num_resources   = placedb.numResources();
  int32_t selected_rsc_id = -1;
  for (int32_t rsc_id = 0; rsc_id < num_resources; rsc_id++) {
    const auto &area_type_ids = placedb.resourceAreaTypes(Resource(rsc_id));
    bool is_contained = std::find(area_type_ids.begin(), area_type_ids.end(), area_type_id) != area_type_ids.end();
    if (is_contained) {
      openparfAssert(selected_rsc_id == -1);
      selected_rsc_id = rsc_id;
    }
  }
  return selected_rsc_id;
}

class ValidSiteMap {
  using IndexType = database::PlaceDB::IndexType;

 public:
  explicit ValidSiteMap(const SiteMap &site_map) : site_map_(site_map) {
    valid_site_map_.resize(site_map.width(), site_map.height(), std::numeric_limits<IndexType>::max());
    for (auto const &site : site_map) {
      auto const &bbox = site.bbox();
      for (int32_t ix = bbox.xl(); ix < bbox.xh(); ++ix) {
        for (int32_t iy = bbox.yl(); iy < bbox.yh(); ++iy) {
          valid_site_map_(ix, iy) = site_map.index1D(site.siteMapId().x(), site.siteMapId().y());
        }
      }
    }
  }

  Site const &getValidSite(IndexType ix, IndexType iy) {
    auto        id1d = valid_site_map_(ix, iy);
    auto const &site = site_map_.at(id1d);
    openparfAssert(site);
    return *site;
  }

 private:
  const SiteMap      &site_map_;
  Vector2D<IndexType> valid_site_map_;
};

class Cell {
 public:
  explicit Cell(int32_t id, XY<float> pos, float height, Range x_range, Range y_range)
      : id_(id),
        pos_(pos),
        height_(height),
        x_range_(x_range),
        y_range_(y_range) {}
  // Identity oriented getters and setters
  int32_t          id() { return id_; }
  XY<float>       &pos() { return pos_; }
  const XY<float> &pos() const { return pos_; }
  float           &height() { return height_; }
  const float     &height() const { return height_; }
  float            yh() { return pos_.y() + height_; }
  float            yl() { return pos_.y(); }
  int32_t          range_xmin() { return x_range_.first; }
  int32_t const    range_xmin() const { return x_range_.first; }
  int32_t          range_xmax() { return x_range_.second; }
  int32_t const    range_xmax() const { return x_range_.second; }
  int32_t         &range_ymin() { return y_range_.first; }
  int32_t const   &range_ymin() const { return y_range_.first; }
  int32_t         &range_ymax() { return y_range_.second; }
  int32_t const   &range_ymax() const { return y_range_.second; }

 private:
  int32_t   id_;
  XY<float> pos_;
  float     height_;
  Range     x_range_;
  Range     y_range_;
};

class CellList {
 public:
  int32_t                     size() const { return cells_.size(); }

  std::vector<Cell>          &cells() { return cells_; }

  std::vector<Cell> const    &cells() const { return cells_; }

  Cell                       &cell(int32_t id) { return cells_[id]; }

  Cell const                 &cell(int32_t id) const { return cells_[id]; }

  std::vector<int32_t> const &cell_inst_ids(int32_t id) const { return cell_inst_ids_list_[id]; }

  Cell                       &operator[](int32_t id) { return cells_[id]; }

  Cell const                 &operator[](int32_t id) const { return cells_[id]; }

  Cell &emplace_back(XY<float> pos, float height, Range x_range, Range y_range, std::vector<int32_t> cell_inst_ids) {
    cells_.emplace_back(cells_.size(), pos, height, x_range, y_range);
    cell_inst_ids_list_.emplace_back(std::move(cell_inst_ids));
    return cells_.back();
  }

 private:
  std::vector<Cell>                 cells_;
  std::vector<std::vector<int32_t>> cell_inst_ids_list_;
};

class Cluster {
 public:
  std::vector<Cell>        cells;
  std::vector<float>       cell_offsets;

  float                    height() const { return cell_offsets.back() + cells.back().height(); }

  std::shared_ptr<Cluster> next;

  float                    cost;
  float                    prefix_cost;

  float                    Yc;

  explicit Cluster(Cell c, std::shared_ptr<Cluster> next_ptr)
      : Yc(c.pos().y()),
        cost(0),
        prefix_cost(0),
        next(std::move(next_ptr)) {
    cells.push_back(c);
    cell_offsets.push_back(0);
  }

  /**
   * @brief return true if |this| is below the |other|
   *
   * @param other
   * @return true
   * @return false
   */
  bool overlap_with(const Cluster &other) const {
    float top    = this->Yc;
    float bottom = other.Yc + other.height();
    return top < bottom;
  }

  /**
   * @brief |this| must have lower y than |other|. Meanwhile, the caller should take care of
   * the |next| pointer of the return Cluster object. This pointer by default is set
   * to |this->next|
   * @param other
   * @return Cluster
   */
  Cluster merge_with(const Cluster &other) const {
    Cluster cluster      = *this;

    auto    cells_to_add = other.cells;

    for (auto &cell : cells_to_add) {
      float cell_offset = cluster.height();
      cluster.cells.push_back(cell);
      cluster.cell_offsets.push_back(cell_offset);
    }

    return cluster;
  }

  template<class T>
  void update(int32_t yl, int32_t yh, float site_height, CellList &cell_list, T *pos) {
    update_Yc(yl, yh, site_height, cell_list, pos);
    update_cost();
  }

 private:
  void update_cost() {
    float new_cost = 0;

    for (size_t i = 0; i < cells.size(); i++) {
      auto &cell   = cells[i];
      float weight = cell.height();
      float off    = Yc + cell_offsets[i] - cell.pos().y();
      new_cost += off * off * weight;
    }

    cost = new_cost;
    if (next != nullptr) {
      prefix_cost = next->prefix_cost + cost;
    }
  }

  /**
   * Updated the optimal y coordinate of the left-bottom corner of this cluster
   * @param n_rows # of rows
   */
  template<class T>
  void update_Yc(float yl, float yh, float site_height, CellList &cell_list, T *pos) {
    float coefficient = 0;
    float weight_sum  = 0;

    for (size_t i = 0; i < cells.size(); i++) {
      auto &cell   = cells[i];
      float weight = cell.height();
      coefficient += (cell.pos().y() - cell_offsets[i]) * weight;
      weight_sum += weight;
    }

    float optimal_y = coefficient / weight_sum;
    // round to the nearest yl + site_height * k
    Yc              = std::round((optimal_y - yl) / site_height) * site_height + yl;

    // Yc + height() <= yh && yl <= Yc
    float Yc_max    = yh - height();
    float Yc_min    = yl;

    for (size_t i = 0; i < cells.size(); i++) {
      // cell.range_ymin() <= Yc + cell_offset && Yc + cell_offset + cell.height() < cell.range_ymax()
      Yc_max = std::min(Yc_max, cells[i].range_ymax() - cell_offsets[i] - cells[i].height());
      Yc_min = std::max(Yc_min, cells[i].range_ymin() - cell_offsets[i]);
    }

    // if (Yc_min > Yc_max) {
    //   for (size_t cell_i = 0; cell_i < cells.size(); cell_i++) {
    //     std::cerr << "=====" << std::endl;
    //     std::cerr << "cell " << cell_i << " : " << cells[cell_i].pos().x() << " " << cells[cell_i].pos().y() << " "
    //               << cells[cell_i].height() << " y range " << cells[cell_i].range_ymin() << " "
    //               << cells[cell_i].range_ymax() << " -> " << Yc + cell_offsets[cell_i] << " "
    //               << Yc + cell_offsets[cell_i] + cells[cell_i].height() << std::endl;
    //     auto &cell_inst_ids = cell_list.cell_inst_ids(cells[cell_i].id());
    //     for (auto inst_id : cell_inst_ids) {
    //       std::cerr << "  inst " << inst_id << " : " << pos[inst_id << 1] << " " << pos[inst_id << 1 | 1] <<
    //       std::endl;
    //     }
    //   }
    // }

    openparfAssertMsg(Yc_min <= Yc_max, "Yc_min = %f, Yc_max = %f", Yc_min, Yc_max);

    Yc = std::min(std::max(Yc, Yc_min), Yc_max);

    // Yc must by yl + site_height * k
    openparfAssertMsg(std::abs(Yc - std::round((Yc - yl) / site_height) * site_height - yl) < 1e-6,
            "Yc = %f, yl = %f, site_height = %f", Yc, yl, site_height);
  }
};

class ColumnPlacement {
 public:
  ColumnPlacement() : root(nullptr), height_sum(0) {}
  std::shared_ptr<Cluster> root;
  float                    height_sum;
};

template<class T>
Range buildXRange(const std::vector<int32_t> &cell_inst_ids,
        const int32_t                        *region_inst_map_b2as,
        const T                              *region_boxes,
        int32_t                               num_site_x) {
  int32_t xmin = 0;
  int32_t xmax = num_site_x;
  for (int32_t inst_id : cell_inst_ids) {
    int32_t region_id = region_inst_map_b2as[inst_id];

    // skip the cell if it does not belong to any region
    if (region_id == -1) {
      continue;
    }

    int32_t xl = static_cast<int32_t>(region_boxes[region_id << 2]);
    int32_t xh = static_cast<int32_t>(region_boxes[region_id << 2 | 2]);

    xmin       = std::max(xmin, xl);
    xmax       = std::min(xmax, xh);
  }
  return std::make_pair(xmin, xmax);
}

/**
 * @brief
 *
 * @param cell_inst_ids
 * @param region_inst_map_b2as
 * @param region_boxes
 * @param num_site_y
 * @return Range
 *
 * Assumption: A shape must be contained in a single region. The cells in a shape CANNOT be in different regions.
 */
template<class T>
Range buildYRange(const std::vector<int32_t> &cell_inst_ids,
        const int32_t                        *region_inst_map_b2as,
        const T                              *region_boxes,
        int32_t                               num_site_y) {
  int32_t ymin = 0;
  int32_t ymax = num_site_y;
  for (int32_t inst_id : cell_inst_ids) {
    int32_t region_id = region_inst_map_b2as[inst_id];

    // skip the cell if it does not belong to any region
    if (region_id == -1) {
      continue;
    }

    int32_t yl = static_cast<int32_t>(region_boxes[region_id << 2 | 1]);
    int32_t yh = static_cast<int32_t>(region_boxes[region_id << 2 | 3]);

    ymin       = std::max(ymin, yl);
    ymax       = std::min(ymax, yh);
  }
  return std::make_pair(ymin, ymax);
}

}   // namespace detail

template<class T>
void mixedAbacusLegalize(database::PlaceDB const &placedb,
        T                                        *pos,
        int32_t                                  *lg_inst_ids,
        int32_t                                   area_type_id,
        int32_t                                  *shape_inst_map_bs,
        int32_t                                  *shape_inst_map_b_starts,
        int32_t                                  *shape_inst_map_b2as,
        int32_t                                  *region_inst_map_b2as,
        T                                        *region_boxes,
        int32_t                                   num_lg_insts,
        int32_t                                   num_shapes,
        int32_t                                   num_insts,
        int32_t                                   num_regions) {
  using detail::Cell;
  using detail::CellList;
  using detail::Cluster;
  using detail::ColumnPlacement;
  using detail::ValidSiteMap;
  std::string                  at_name      = placedb.place_params().area_type_names_[area_type_id];
  auto const                  &layout       = placedb.db()->layout();
  auto const                  &place_params = placedb.place_params();
  int32_t                      rsc_id       = detail::SelectResource(placedb, area_type_id);
  const database::SiteMap     &site_map     = layout.siteMap();
  ValidSiteMap                 valid_site_map(site_map);
  int32_t                      num_site_x = placedb.siteMapDim().x();
  int32_t                      num_site_y = placedb.siteMapDim().y();
  std::vector<int32_t>         ssr_col_heights(num_site_x, 0);
  std::vector<int32_t>         col_yl(num_site_x, num_site_y);
  std::vector<int32_t>         col_yh(num_site_x, 0);
  int32_t                      total_ssr_sup = 0;
  std::vector<int32_t>         col_ssr_sups(num_site_x, 0);
  std::vector<ColumnPlacement> heads(num_site_x);
  CellList                     cell_list;
  std::unordered_set<int32_t>  lg_inst_ids_set(lg_inst_ids, lg_inst_ids + num_lg_insts);
  int32_t                      num_feasible_sites = 0;
  for (const Site &site : site_map) {
    if (layout.siteType(site).resourceCapacity(rsc_id) > 0) {
      int32_t xl = site.bbox().xl();
      int32_t yl = site.bbox().yl();
      int32_t yh = site.bbox().yh();
      col_yl[xl] = std::min(col_yl[xl], yl);
      col_yh[xl] = std::max(col_yh[xl], yh);
      ssr_col_heights[xl] += yh - yl;
      num_feasible_sites++;
    }
  }

  int32_t num_feasible_cols = std::accumulate(ssr_col_heights.begin(), ssr_col_heights.end(), 0.,
          [&](int a, int b) { return a + (b > 0); });
  float   site_height       = std::accumulate(ssr_col_heights.begin(), ssr_col_heights.end(), 0., [&](float a, int b) {
    return a + b;
  }) / num_feasible_sites;


  int32_t macro_cell_count  = 0;
  int32_t macro_cell_region_count = 0;

  // add macro cells, DO NOT legalize the cells that are NOT in a shape
  for (int shape_id = 0; shape_id < num_shapes; shape_id++) {
    int32_t              st = shape_inst_map_b_starts[shape_id];
    int32_t              en = shape_inst_map_b_starts[shape_id + 1];
    std::vector<int32_t> cell_inst_ids(shape_inst_map_bs + st, shape_inst_map_bs + en);

    int32_t              len    = en - st;
    float                height = site_height * len;

    // skip the shape if it is not in the legalizer
    if (lg_inst_ids_set.find(cell_inst_ids[0]) == lg_inst_ids_set.end()) {
      continue;
    }

    float center_x = std::accumulate(cell_inst_ids.begin(), cell_inst_ids.end(), 0., [&](float a, int32_t new_inst_id) {
      return a + pos[new_inst_id << 1];
    }) / len;
    float center_y = std::accumulate(cell_inst_ids.begin(), cell_inst_ids.end(), 0., [&](float a, int32_t new_inst_id) {
      return a + pos[new_inst_id << 1 | 1];
    }) / len;


    float bl_x     = center_x - 0.5;
    float bl_y     = center_y - height * 0.5;

    Range x_range  = detail::buildXRange(cell_inst_ids, region_inst_map_b2as, region_boxes, num_site_x);
    Range y_range  = detail::buildYRange(cell_inst_ids, region_inst_map_b2as, region_boxes, num_site_y);

    cell_list.emplace_back(XY<float>(bl_x, bl_y), height, x_range, y_range, cell_inst_ids);

    macro_cell_count++;

    if (y_range != std::make_pair(0, num_site_y)) {
      macro_cell_region_count++;
    }
  }

  openparfPrint(kInfo, "===============================\n");
  openparfPrint(kInfo, "Start Mixed Abacus Legalization\n");
  openparfPrint(kInfo, "area type           : %s(%d)\n", at_name.c_str(), area_type_id);
  openparfPrint(kInfo, "resouce type        : %d\n", rsc_id);
  openparfPrint(kInfo, "num_feasible_cols   : %d\n", num_feasible_cols);
  openparfPrint(kInfo, "site_height         : %f\n", site_height);
  openparfPrint(kInfo, "macro_cell_count    : %d\n", macro_cell_count);
  openparfPrint(kInfo, "macro_cell_region   : %d\n", macro_cell_region_count);

  std::vector<Cell> &cells = cell_list.cells();

  std::sort(cells.begin(), cells.end(), [](const Cell &a, const Cell &b) -> bool {
    return a.pos().y() == b.pos().y() ? a.height() > b.height() : a.pos().y() < b.pos().y();
    // return a.height() == b.height() ? a.pos().y() < b.pos().y() : a.height() > b.height();
  });

  for (auto &cell : cells) {
    float                    best_added_cost = std::numeric_limits<float>::max();
    int                      best_col        = std::numeric_limits<int>::max();
    std::shared_ptr<Cluster> best_col_first_cluster;
    int                      ix = std::floor(cell.pos().x());
    for (int dx = 0; dx < num_site_x; dx++) {
      for (int sign : {1, -1}) {
        int Xc = ix + dx * sign;

        // skip the column if it is not feasible
        if (!(0 <= Xc && Xc < num_site_x)) {
          continue;
        }

        if (!(cell.range_xmin() <= Xc && Xc < cell.range_xmax())) {
          continue;
        }

        float x_cost = (cell.pos().x() - Xc) * (cell.pos().x() - Xc);

        if (x_cost >= best_added_cost) {
          continue;
        }

        ColumnPlacement &head = heads[Xc];

        // skip the column if it is overfull
        if (head.height_sum + cell.height() > ssr_col_heights[Xc]) {
          continue;
        }

        float column_origin_cost = head.root != nullptr ? head.root->prefix_cost : 0;

        auto  cluster            = std::make_shared<Cluster>(cell, head.root);
        cluster->update(col_yl[Xc], col_yh[Xc], site_height, cell_list, pos);

        while (cluster->next != nullptr && cluster->overlap_with(*cluster->next)) {
          *cluster = cluster->next->merge_with(*cluster);
          cluster->update(col_yl[Xc], col_yh[Xc], site_height, cell_list, pos);
        }

        float added_cost = x_cost + cluster->prefix_cost - column_origin_cost;
        if (added_cost < best_added_cost) {
          best_col               = Xc;
          best_added_cost        = added_cost;
          best_col_first_cluster = cluster;
        }
      }
    }

    assert(best_col != std::numeric_limits<int>::max());

    /* update */ {
      ColumnPlacement &head = heads[best_col];
      head.root             = best_col_first_cluster;
      head.height_sum += cell.height();
    }
  }

  float   total_movement_x = 0;
  float   total_movement_y = 0;
  int32_t move_cell_count  = 0;

  for (size_t Xc = 0; Xc < num_site_x; Xc++) {
    ColumnPlacement &head = heads[Xc];
    for (auto cluster = head.root; cluster; cluster = cluster->next) {
      for (size_t j = 0; j < cluster->cells.size(); j++) {
        auto                       &cell = cluster->cells[j];
        XY<float>                   rv(Xc, cluster->Yc + cluster->cell_offsets[j]);
        std::vector<int32_t> const &cell_inst_ids = cell_list.cell_inst_ids(cell.id());
        for (size_t cell_i = 0; cell_i < cell_inst_ids.size(); cell_i++) {
          int32_t cell_inst_id = cell_inst_ids[cell_i];
          float   lb_y         = rv.y() + site_height * cell_i;
          // lb_y must be yl + site_height * k
          openparfAssertMsg(
                  std::abs(lb_y - std::round((lb_y - col_yl[Xc]) / site_height) * site_height - col_yl[Xc]) < 1e-6,
                  "lb_y = %f, col_yl[Xc] = %f, site_height = %f", lb_y, col_yl[Xc], site_height);
          auto &site                 = valid_site_map.getValidSite(rv.x(), lb_y);

          float old_pos_x            = pos[cell_inst_id << 1];
          float old_pos_y            = pos[cell_inst_id << 1 | 1];

          pos[cell_inst_id << 1]     = site.bbox().xl() + site.bbox().width() * 0.5;
          pos[cell_inst_id << 1 | 1] = site.bbox().yl() + site.bbox().height() * 0.5;

          float movement_x           = std::abs(pos[cell_inst_id << 1] - old_pos_x);
          float movement_y           = std::abs(pos[cell_inst_id << 1 | 1] - old_pos_y);
          total_movement_x += movement_x;
          total_movement_y += movement_y;

          // std::cerr << "move cell " << cell_inst_id << " from (" << old_pos_x << ", " << old_pos_y << ") to ("
          //           << pos[cell_inst_id << 1] << ", " << pos[cell_inst_id << 1 | 1] << "), "
          //           << "movement_x = " << movement_x << ", movement_y = " << movement_y << std::endl;
          move_cell_count++;
        }
      }
    }
  }

  openparfPrint(kInfo, "move_cell_count :%d\n", move_cell_count);
  openparfPrint(kInfo, "avg_movement_x  :%f\n", total_movement_x / move_cell_count);
  openparfPrint(kInfo, "avg_movement_y  :%f\n", total_movement_y / move_cell_count);
}

void mixedAbacusLegalizerForward(database::PlaceDB const &placedb,
        at::Tensor                                        pos,
        at::Tensor                                        lg_inst_ids,
        int32_t                                           area_type_id,
        at::Tensor                                        shape_inst_map_bs,
        at::Tensor                                        shape_inst_map_b_starts,
        at::Tensor                                        shape_inst_map_b2as,
        at::Tensor                                        region_inst_map_b2as,
        at::Tensor                                        region_boxes) {
  CHECK_FLAT_CPU(pos);
  CHECK_EVEN(pos);
  CHECK_CONTIGUOUS(pos);
  CHECK_FLAT_CPU(lg_inst_ids);
  CHECK_CONTIGUOUS(lg_inst_ids);
  CHECK_TYPE(lg_inst_ids, torch::kInt32);
  CHECK_FLAT_CPU(shape_inst_map_bs);
  CHECK_CONTIGUOUS(shape_inst_map_bs);
  CHECK_TYPE(shape_inst_map_bs, torch::kInt32);
  CHECK_FLAT_CPU(shape_inst_map_b_starts);
  CHECK_CONTIGUOUS(shape_inst_map_b_starts);
  CHECK_TYPE(shape_inst_map_b_starts, torch::kInt32);
  CHECK_FLAT_CPU(shape_inst_map_b2as);
  CHECK_CONTIGUOUS(shape_inst_map_b2as);
  CHECK_TYPE(shape_inst_map_b2as, torch::kInt32);
  CHECK_FLAT_CPU(region_inst_map_b2as);
  CHECK_CONTIGUOUS(region_inst_map_b2as);
  CHECK_TYPE(region_inst_map_b2as, torch::kInt32);
  CHECK_FLAT_CPU(region_boxes);
  CHECK_CONTIGUOUS(region_boxes);
  CHECK_TYPE(region_boxes, pos.dtype());
  CHECK_DIVISIBLE(region_boxes, 4);

  int32_t num_lg_insts = lg_inst_ids.numel();
  int32_t num_shapes   = shape_inst_map_b_starts.numel() - 1;
  int32_t num_insts    = shape_inst_map_b2as.numel();
  int32_t num_regions  = region_boxes.numel() / 4;

  AT_ASSERTM(num_insts == region_inst_map_b2as.numel(), "num_insts != region_inst_map_b2as.numel()");

  OPENPARF_DISPATCH_FLOATING_TYPES(pos, "ChainLegalizerForward", [&] {
    mixedAbacusLegalize(placedb, OPENPARF_TENSOR_DATA_PTR(pos, scalar_t),
            OPENPARF_TENSOR_DATA_PTR(lg_inst_ids, int32_t), area_type_id,
            OPENPARF_TENSOR_DATA_PTR(shape_inst_map_bs, int32_t),
            OPENPARF_TENSOR_DATA_PTR(shape_inst_map_b_starts, int32_t),
            OPENPARF_TENSOR_DATA_PTR(shape_inst_map_b2as, int32_t),
            OPENPARF_TENSOR_DATA_PTR(region_inst_map_b2as, int32_t), OPENPARF_TENSOR_DATA_PTR(region_boxes, scalar_t),
            num_lg_insts, num_shapes, num_insts, num_regions);
  });
}

#define REGISTER_KERNEL_LAUNCHER(T)                                                                                    \
  template void mixedAbacusLegalize<T>(database::PlaceDB const &placedb, T *pos, int32_t *lg_inst_ids,                 \
          int32_t area_type_id, int32_t *shape_inst_map_bs, int32_t *shape_inst_map_b_starts,                          \
          int32_t *shape_inst_map_b2as, int32_t *region_inst_map_b2as, T *region_boxes, int32_t num_lg_insts,          \
          int32_t num_shapes, int32_t num_insts, int32_t num_regions);

REGISTER_KERNEL_LAUNCHER(float)
REGISTER_KERNEL_LAUNCHER(double)

#undef REGISTER_KERNEL_LAUNCHER

}   // namespace mixed_abacus_legalizer

OPENPARF_END_NAMESPACE

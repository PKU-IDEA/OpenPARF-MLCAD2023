/*
 * @file          : shape.h
 * @project       : database
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : June 28 2023, 15:51:51, Wednesday
 * @brief         :
 * -----
 * Last Modified: July 24 2023, 22:37:27, Monday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */

#ifndef OPENPARF_DATABASE_SHAPE_H_
#define OPENPARF_DATABASE_SHAPE_H_

#include <algorithm>
#include <string>
#include <unordered_set>
#include <utility>
#include <vector>

#include "database/object.h"
#include "geometry/geometry.hpp"

OPENPARF_BEGIN_NAMESPACE

namespace database {

class ShapeElement : public Object {
  using BaseType  = Object;
  using IndexType = BaseType::IndexType;
  using PointType = geometry::Point<IndexType, 2>;

 public:
  /// @brief getter for model id
  IndexType        model_id() const { return model_id_; }
  /// @brief setter for model id
  void             setModelId(IndexType id) { model_id_ = id; }
  /// @brief getter for offset
  PointType const &offset() const { return offset_; }
  /// @brief setter for offset
  void             setOffset(PointType const &o) { offset_ = o; }

 protected:
  /// @brief overload output stream
  friend std::ostream &operator<<(std::ostream &os, ShapeElement const &rhs);

  IndexType            model_id_;   ///< model id
  PointType            offset_;     ///< The x, y of this element. A relative position to the
                                    ///< first node
};

/// @brief Class for shape constraint in placement.
/// A shape constraint requires that a set of cells must be placed in a certain
/// pattern. Typically the pattern is a column with width of 1
class ShapeModel : public Object {
 public:
  using BaseType  = Object;
  using IndexType = BaseType::IndexType;
  using PointType = geometry::Point<IndexType, 2>;

  /// @brief default constructor
  ShapeModel() : BaseType(), type_(ShapeModelType::kUnknown) {}

  /// @brief constructor
  explicit ShapeModel(IndexType id) : BaseType(id), type_(ShapeModelType::kUnknown) {}

  /// @brief copy constructor
  ShapeModel(ShapeModel const &rhs) { copy(rhs); }

  /// @brief move constructor
  ShapeModel(ShapeModel &&rhs) noexcept { move(std::move(rhs)); }

  /// @brief copy assignment
  ShapeModel &operator=(ShapeModel const &rhs) {
    if (this != &rhs) {
      copy(rhs);
    }
    return *this;
  }

  /// @brief move constructor
  ShapeModel &operator=(ShapeModel &&rhs) noexcept {
    if (this != &rhs) {
      move(std::move(rhs));
    }
    return *this;
  }

  /// @brief getter for type
  ShapeModelType                   type() const { return type_; }

  /// @brief setter for type
  void                             setType(ShapeModelType const &v) { type_ = v; }

  /// @brief getter for name
  std::string const               &name() const { return name_; }

  /// @brief setter for name
  void                             setName(std::string const &n) { name_ = n; }

  /// @brief number of elements
  IndexType                        numShapeElements() const { return elements_.size(); }

  /// @brief getter for element
  ShapeElement const              &shapeElement(IndexType i) const { return elements_[i]; }

  /// @brief getter for element
  ShapeElement                    &shapeElement(IndexType i) { return elements_[i]; }

  /// @brief getter for elements
  std::vector<ShapeElement> const &shapeElements() const { return elements_; }

  /// @brief add a shape element
  ShapeElement                    &addShapeElement(IndexType model_id, PointType const &offset);

  /// @brief summarize memory usage of the object in bytes
  IndexType                        memory() const;

 protected:
  /// @brief copy object
  void                      copy(ShapeModel const &rhs);
  /// @brief move object
  void                      move(ShapeModel &&rhs);
  /// @brief overload output stream
  friend std::ostream      &operator<<(std::ostream &os, ShapeModel const &rhs);

  ShapeModelType            type_;       ///< type of the shape model
  std::string               name_;       ///< name of the shape model
  std::vector<ShapeElement> elements_;   ///< all shape elements of this model
};


/// @brief Class for shape constraint in placement.
class Shape : public Object {
 public:
  using BaseType  = Object;
  using IndexType = BaseType::IndexType;

  /// @brief default constructor
  Shape() : BaseType(), shape_model_id_(invalidIndex) {}


  /// @brief constructor
  explicit Shape(IndexType id) : BaseType(id), shape_model_id_(invalidIndex) {}

  /// @brief copy constructor
  Shape(Shape const &rhs) { copy(rhs); }

  /// @brief move constructor
  Shape(Shape &&rhs) noexcept { move(std::move(rhs)); }

  /// @brief copy assignment
  Shape &operator=(Shape const &rhs) {
    if (this != &rhs) {
      copy(rhs);
    }
    return *this;
  }

  /// @brief move constructor
  Shape &operator=(Shape &&rhs) noexcept {
    if (this != &rhs) {
      move(std::move(rhs));
    }
    return *this;
  }

  /// @brief getter for shape model id
  IndexType                     shapeModelId() const { return shape_model_id_; }

  /// @brief setter for shape model id
  void                          setShapeModelId(IndexType id) { shape_model_id_ = id; }

  /// @brief getter for name
  std::string const            &name() const { return name_; }

  /// @brief setter for name
  void                          setName(std::string const &n) { name_ = n; }

  /// @brief number of instances
  IndexType                     numInstances() const { return inst_ids_.size(); }

  /// @brief getter for instance id
  IndexType                     instId(IndexType i) const { return inst_ids_[i]; }

  /// @brief getter for instance ids
  std::vector<IndexType> const &instIds() const { return inst_ids_; }

  /// @brief add an instance id
  void                          addinstId(IndexType id) { inst_ids_.push_back(id); }

  /// @brief summarize memory usage of the object in bytes
  IndexType                     memory() const;

 protected:
  /// @brief copy object
  void                   copy(Shape const &rhs);
  /// @brief move object
  void                   move(Shape &&rhs);
  /// @brief overload output stream
  friend std::ostream   &operator<<(std::ostream &os, Shape const &rhs);

  IndexType              shape_model_id_;   ///< shape model id
  std::string            name_;             ///< name of the shape constraint
  std::vector<IndexType> inst_ids_;         ///< instance ids
};

using ShapeModelMap = ObjectMap<ShapeModel>;
using ShapeMap      = ObjectMap<Shape>;

class ShapeConstraint : public Object {
 public:
  using BaseType = Object;

  /// @brief default constructor
  ShapeConstraint() : Object(), shape_models_(), shapes_() {}

  /// @brief constructor
  explicit ShapeConstraint(IndexType id) : Object(id), shape_models_(), shapes_() {}

  /// @brief copy constructor
  ShapeConstraint(ShapeConstraint const &rhs) { copy(rhs); }

  /// @brief move constructor
  ShapeConstraint(ShapeConstraint &&rhs) noexcept { move(std::move(rhs)); }

  /// @brief copy assignment
  ShapeConstraint &operator=(ShapeConstraint const &rhs) {
    if (this != &rhs) {
      copy(rhs);
    }
    return *this;
  }

  /// @brief move constructor
  ShapeConstraint &operator=(ShapeConstraint &&rhs) noexcept {
    if (this != &rhs) {
      move(std::move(rhs));
    }
    return *this;
  }

  /// @brief number of shape models
  IndexType            numShapeModels() const { return shape_models_.size(); }

  /// @brief getter for shape model
  ShapeModel const    &shapeModel(IndexType id) const { return shape_models_.at(id); }

  /// @brief getter for shape model
  ShapeModel          &shapeModel(IndexType id) { return shape_models_.at(id); }

  /// @brief getter for shape model id
  IndexType            shapeModelId(std::string const &name) const { return shape_models_.at(name).id(); }

  /// @brief try to add a shape model
  ShapeModel          &tryAddShapeModel(std::string const &name);

  /// @brief getter for shape models
  ShapeModelMap const &shapeModels() const { return shape_models_; }

  /// @brief getter for shape models
  ShapeModelMap       &shapeModels() { return shape_models_; }

  /// @brief number of shapes
  IndexType            numShapes() const { return shapes_.size(); }

  /// @brief getter for shape
  Shape const         &shape(IndexType id) const { return shapes_.at(id); }

  /// @brief getter for shape
  Shape               &shape(IndexType id) { return shapes_.at(id); }

  /// @brief try to add a shape
  Shape               &tryAddShape(std::string const &name);

  /// @brief getter for shapes
  ShapeMap const      &shapes() const { return shapes_; }

  /// @brief getter for shapes
  ShapeMap            &shapes() { return shapes_; }

  /// @brief build instance shape ids set
  void                 buildInstShapeIdsSet() {
    inst_shape_ids_set_.clear();
    for (auto const &shape : shapes_) {
      for (auto const &inst_id : shape.instIds()) {
        inst_shape_ids_set_.insert(inst_id);
      }
    }
  }

  /// @brief whether the instance is in the shape constraint
  bool      hasInst(IndexType inst_id) const { return inst_shape_ids_set_.count(inst_id) > 0; }

  /// @brief summarize memory usage of the object in bytes
  IndexType memory() const;

 protected:
  /// @brief copy object
  void                          copy(ShapeConstraint const &rhs);

  /// @brief move object
  void                          move(ShapeConstraint &&rhs);

  /// @brief overload output stream
  friend std::ostream          &operator<<(std::ostream &os, ShapeConstraint const &rhs);

  ShapeModelMap                 shape_models_;
  ShapeMap                      shapes_;
  std::unordered_set<IndexType> inst_shape_ids_set_;
};

}   // namespace database

OPENPARF_END_NAMESPACE

#endif   // OPENPARF_DATABASE_SHAPE_H_

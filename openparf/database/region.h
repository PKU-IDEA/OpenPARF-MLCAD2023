/*
 * @file          : region.h
 * @project       : database
 * @author        : Jing Mai <jingmai@pku.edu.cn>
 * @created date  : July 03 2023, 11:29:10, Monday
 * @brief         :
 * -----
 * Last Modified: July 23 2023, 14:08:30, Sunday
 * Modified By: Jing Mai <jingmai@pku.edu.cn>
 * -----
 * @history :
 * ====================================================================================
 * Date         	By     	(version)	Comments
 * -------------	-------	---------	--------------------------------------------------
 * ====================================================================================
 * Copyright (c) 2020 - 2023 All Right Reserved, PKU-IDEA Group
 * -----
 * This header is generated by VSCode extension psi-header.
 */
#ifndef OPENPARF_DATABASE_REGION_H_
#define OPENPARF_DATABASE_REGION_H_

#include <algorithm>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "container/flat_nested_vector.hpp"
#include "database/layout_map.hpp"
#include "geometry/geometry.hpp"
#include "util/util.h"
OPENPARF_BEGIN_NAMESPACE

namespace database {

/// @brief  region
class Region : public Object {
 public:
  using BaseType  = Object;
  using IndexType = BaseType::IndexType;
  using BoxType   = geometry::Box<IndexType>;

  /// @brief default constructor
  Region() : BaseType() {}

  /// @brief constructor
  explicit Region(IndexType id) : BaseType(id) {}

  /// @brief copy constructor
  Region(Region const &rhs) { copy(rhs); }

  /// @brief move constructor
  Region(Region &&rhs) noexcept { move(std::move(rhs)); }

  /// @brief copy assignment
  Region &operator=(Region const &rhs) {
    if (this != &rhs) {
      copy(rhs);
    }
    return *this;
  }

  /// @brief move assignment
  Region &operator=(Region &&rhs) noexcept {
    if (this != &rhs) {
      move(std::move(std::move(rhs)));
    }
    return *this;
  }

  /// @brief get name
  std::string const            &name() const { return name_; }

  /// @brief set name
  void                          setName(std::string const &name) { name_ = name; }

  /// @brief get bounding box
  BoxType const                &bbox() const { return bbox_; }

  /// @brief set bounding box
  void                          setBbox(BoxType const &bbox) { bbox_ = bbox; }

  /// @brief get instance ids
  std::vector<IndexType> const &instIds() const { return inst_ids_; }

  /// @brief get instance ids
  std::vector<IndexType>       &instIds() { return inst_ids_; }

  /// @brief get number of instances
  IndexType                     numInsts() const { return inst_ids_.size(); }

  /// @brief get instance id
  IndexType                     instId(IndexType idx) const { return inst_ids_[idx]; }

  /// @brief add instance id
  void                          addInstId(IndexType inst_id) { inst_ids_.emplace_back(inst_id); }

  /// @brief whether contain point
  template<typename PointCoordinateType>
  bool contain(geometry::Point<PointCoordinateType, 2> const &p) const {
    return bbox_.contain(p);
  }

  /// @brief whether contain point
  template<typename PointCoordinateType>
  bool contain(PointCoordinateType x, PointCoordinateType y) const {
    return bbox_.contain(x, y);
  }

 protected:
  /// @brief copy object
  void                   copy(Region const &rhs);

  /// @brief move object
  void                   move(Region &&rhs) noexcept;

  /// @brief overload output stream
  friend std::ostream   &operator<<(std::ostream &os, Region const &rhs);

  std::string            name_;       ///< name of the region
  BoxType                bbox_;       ///< bounding box
  std::vector<IndexType> inst_ids_;   ///< instance ids
};

using RegionList = ObjectMap<Region>;

class RegionConstraint : public Object {
 public:
  using BaseType  = Object;
  using IndexType = BaseType::IndexType;

  /// @brief default constructor
  RegionConstraint() : BaseType() {}

  /// @brief constructor
  explicit RegionConstraint(IndexType id) : BaseType(id) {}

  /// @brief copy constructor
  RegionConstraint(RegionConstraint const &rhs) { copy(rhs); }


  /// @brief move constructor
  RegionConstraint(RegionConstraint &&rhs) noexcept { move(std::move(rhs)); }

  /// @brief copy assignment
  RegionConstraint &operator=(RegionConstraint const &rhs) {
    if (this != &rhs) {
      copy(rhs);
    }
    return *this;
  }

  /// @brief move assignment
  RegionConstraint &operator=(RegionConstraint &&rhs) noexcept {
    if (this != &rhs) {
      move(std::move(std::move(rhs)));
    }
    return *this;
  }

  /// @brief get region list
  RegionList const &region_list() const { return region_list_; }

  /// @brief get region list
  RegionList       &region_list() { return region_list_; }

  /// @brief get region from id
  Region const     &region(IndexType id) const { return region_list_.at(id); }

  /// @brief get region from id
  Region           &region(IndexType id) { return region_list_.at(id); }

  /// @brief get region from name
  Region const     &region(std::string const &name) const { return region_list_.at(name); }

  /// @brief get region from name
  Region           &region(std::string const &name) { return region_list_.at(name); }

  /// @brief get region id from name
  IndexType         regionId(std::string const &name) const { return region_list_.id(name); }

  /// @brief number of regions
  IndexType         numRegions() const { return region_list_.size(); }

  /// @brief if intance id to region id mapping exists
  bool              ifExist(IndexType inst_id) const { return inst_id2region_id_.count(inst_id) > 0; }

  IndexType         inst2Region(IndexType inst_id) const {
    assert(ifExist(inst_id));
    return inst_id2region_id_.at(inst_id);
  }

  /// @brief try add region
  Region &tryAddRegion(std::string const &name) {
    if (region_list_.ifExist(name)) {
      return region_list_.at(name);
    }
    Region &region = region_list_.tryAdd(name);
    return region;
  }

  /// @brief add instance id to region id mapping
  bool tryAddMapping(IndexType inst_id, const std::string &region_name) {
    if (ifExist(inst_id)) {
      openparfPrint(kWarn, "instance %d already in region %d\n", inst_id, inst_id2region_id_[inst_id]);
      return false;
    }
    Region &reg                 = region(region_name);
    inst_id2region_id_[inst_id] = reg.id();
    reg.addInstId(inst_id);
    return true;
  }

  /// @brief number of regions
  IndexType num_regions() const { return region_list_.size(); }

 protected:
  /// @brief copy object
  void                 copy(RegionConstraint const &rhs);

  /// @brief move object
  void                 move(RegionConstraint &&rhs) noexcept;

  /// @brief overload output stream
  friend std::ostream &operator<<(std::ostream &os, RegionConstraint const &rhs);

  RegionList           region_list_;   ///< region list
  std::unordered_map<IndexType, IndexType>
          inst_id2region_id_;          ///< instance id to region id,
                                       /// assuming that each instance is in at most one region
};

}   // namespace database

OPENPARF_END_NAMESPACE
#endif   // OPENPARF_DATABASE_REGION_H_
